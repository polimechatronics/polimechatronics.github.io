<!doctypehtml><html lang=en><title>Notes | Mechatronic Systems and Laboratory</title><meta charset=UTF-8><meta content="width=device-width,initial-scale=1"name=viewport><link href=../../css/style-w3.css rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto"rel=stylesheet><link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css rel=stylesheet><style>body,h1,h2,h3,h4,h5,h6,html{font-family:Roboto,sans-serif}.w3-sidebar{z-index:3;width:250px;top:43px;bottom:0;height:inherit}.w3-bar{overflow:visible}</style><div class=w3-top><div class="w3-top w3-bar w3-large w3-left-align w3-theme"><a href=javascript:void(0) class="w3-bar-item w3-button w3-hover-white w3-hide-large w3-large w3-right w3-theme-l1"onclick=w3_open()><i class="fa fa-bars"></i></a> <a href=../../ class="w3-bar-item w3-button w3-theme-l1">Home</a> <a href=../../laboratory.html class="w3-bar-item w3-button w3-hover-white w3-hide-small">Laboratory</a> <a href=../../computer-lab.html class="w3-bar-item w3-button w3-hover-white w3-hide-small">Computer Lab</a> <a href=../../theses.html class="w3-bar-item w3-button w3-hover-white w3-hide-small">Theses</a><div class=w3-dropdown-hover><a href=../../notes.html class="w3-button w3-hover-white w3-hide-small">Notes</a><div class="w3-bar-block w3-card-4 w3-dropdown-content"id=notes-bar-item><a href=../introduction.html class="w3-bar-item w3-button">Introduction</a> <a href=../nonlinear-programming.html class="w3-bar-item w3-button">Optimization</a> <a href=../calculus-of-variations.html class="w3-bar-item w3-button">Calculus Of Variations</a> <a href=../optimal-control.html class="w3-bar-item w3-button">Optimal Control</a> <a href=../estimation.html class="w3-bar-item w3-button">Estimation</a> <a href=../smart-materials.html class="w3-bar-item w3-button">Smart Materials</a></div></div></div></div><nav class="w3-bar-block w3-animate-left w3-collapse w3-large w3-sidebar w3-theme-l5"id=mySidebar><a href=javascript:void(0) class="w3-hide-large w3-right w3-hover-black w3-padding-large w3-xlarge"onclick=w3_close() title="Close Menu"><i class="fa fa-remove"></i></a><h4 class=w3-bar-item><b><a href=../nonlinear-programming.html class=chapter-link>2 Optimization</a></b></h4><a href=./notation.html class="w3-bar-item w3-button w3-hover-black">2.1 Notation and definitions</a> <a href=./problem-statement.html class="w3-bar-item w3-button w3-hover-black">2.2 Problem statement</a> <a href=./definitions.html class="w3-bar-item w3-button w3-hover-black">2.3 Definitions</a> <a href=./convex-programming.html class="w3-bar-item w3-button w3-hover-black">2.4 Convex programming</a> <a href=./unconstrained-problems.html class="w3-bar-item w3-button w3-hover-black">2.5 Unconstrained problems</a> <a href=./inequality-constraints.html class="w3-bar-item w3-button w3-hover-black">2.6 Inequality constraints</a> <a href=./equality-constraints.html class="w3-bar-item w3-button w3-hover-black">2.7 Equality constraints</a> <a href=./general-nlp-problems.html class="w3-bar-item w3-button w3-hover-black">2.8 General NLP problems</a> <a href=./numerical-methods.html class="w3-bar-item w3-button w3-hover-black">2.9 Numerical methods</a></nav><div class="w3-hide-large w3-overlay"id=myOverlay onclick=w3_close() style=cursor:pointer title="close side menu"></div><div class=w3-main style=margin-left:250px><div class="w3-padding-64 w3-row"><a id=numerical-methods class=anchor-text></a><div class="w3-container w3-twothird"><h2 class=w3-text-teal><span class=titlemark>2.9</span> <a id=x1-240002.9></a>Numerical methods for nonlinear programming problems</h2><p>Nowadays, strong and efficient mathematical programming techniques are available for solving a great variety of nonlinear problems, which are based on solid theoretical results and extensive numerical studies. Approximated functions, derivatives and optimal solutions can be employed together with optimization algorithms to reduce the computational time. The aim of this section is not to describe state-of-the-art algorithms in nonlinear programming, but to explain, in a simple way, a number of modern algorithms for solving nonlinear problems. These techniques are typically iterative in the sense that, given an initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> , a sequence of points, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>}</mo></math> , is obtained by repeated application of an algorithmic rule. The objective is to make this sequence converge to a point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> in a pre-specified <span class=cmti-10>solution set</span>. Typically, the solution set is specified in terms of optimality conditions, such as those presented in <a href=#x1-140002.5>2.5</a> through <a href=#x1-210002.8>2.8</a>.<p>We start by recalling a number of concepts in <a href=#x1-250002.9.1>2.9.1</a>. Then, we discuss the principles of Newton-like algorithms for nonlinear systems in <a href=#x1-260002.9.2>2.9.2</a>, and use these concepts for the solution of unconstrained optimization problems in <a href=#x1-270002.9.3>2.9.3</a>. Finally, algorithms for solving general nonlinear problems are presented in <a href=#x1-310002.9.7>2.9.7</a>, with emphasizes on sequential unconstrained minimization (SUM) and sequential quadratic programming (SQP) techniques.<h4 class=subsectionHead><span class=titlemark>2.9.1</span> <a id=x1-250002.9.1></a>Preliminaries</h4><p>Two essential questions must be addressed concerning iterative algorithms. The first question, which is qualitative in nature, is whether a given algorithm in some sense yields, at least in the limit, a solution to the original problem; the second question, the more quantitative one, is concerned with how fast the algorithm converges to a solution. We elaborate on these concepts in this subsection.<p>The convergence of an algorithm is said to be <span class=cmti-10>asymptotic</span> when the solution is not achieved after a finite number of iterations; except for particular problems such as linear and quadratic programming, this is generally the case in nonlinear programming. That is, a very desirable property of an optimization algorithm is global convergence: <a id=x1-25001r23></a><div class=mdframed id=mdframed-79><p><span class=cmbx-10>Definition</span><span class=cmbx-10> 2.23:</span> <span class=cmbx-10>Global</span> <span class=cmbx-10>Convergence,</span> <span class=cmbx-10>Local</span> <span class=cmbx-10>Convergence</span><p>An algorithm is said to be globally convergent if, for any initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> , it generates a sequence of points that converges to a point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> in the solution set. It is said to be locally convergent if there exists a <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ρ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> such that for any initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msub><mrow></mrow></msub></mstyle><mrow><mn>0</mn></mrow></math> such that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mrow><mo fence=true form=prefix>‖</mo><mrow><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mn>0</mn></mrow></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>&lt;</mo><mi>ρ</mi></math> it generates a sequence of points converging to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> in the solution set.</div><p>Most modern mathematical programming algorithms are globally convergent. Locally convergent algorithms are not useful in practice because the neighborhood of convergence is not known in advance and can be arbitrarily small.<p>Next, what distinguishes optimization algorithms with the global convergence property is the order of convergence: <a id=x1-25002r24></a><div class=mdframed id=mdframed-80><p><span class=cmbx-10>Definition</span><span class=cmbx-10> 2.24:</span> <span class=cmbx-10>Order</span> <span class=cmbx-10>of</span> <span class=cmbx-10>Convergence</span><p>The order of convergence of a sequence <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>}</mo><mo class=MathClass-rel>→</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> is the largest nonnegative integer p such that<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><munder class=msub><mrow><mi class=qopname>lim</mi><mo>⁡</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></mrow></munder><mfrac><mrow><mrow><mo fence=true form=prefix>∥</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mover accent=false class=mml-overline><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></mrow><mo fence=true form=postfix>∥</mo></mrow><mrow><msup><mrow><mrow><mo fence=true form=prefix>∥</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo class=MathClass-bin>−</mo><mover accent=false class=mml-overline><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></mrow><mo fence=true form=postfix>∥</mo><mrow><mi>p</mi></mrow></mfrac><mo class=MathClass-rel>=</mo><mi>β</mi><mo class=MathClass-rel>&lt;</mo><mi>∞</mi></math></table><p>When <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi><mo class=MathClass-rel>=</mo><mn>1</mn></math> and the convergence ratio <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi><mo class=MathClass-rel>&lt;</mo><mn>1</mn></math> , the convergence is said to be linear; if <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , the convergence is said to be superlinear. When <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi><mo class=MathClass-rel>=</mo><mn>2</mn></math> , the convergence is said to be quadratic.</div><p>Since they involve the limit when <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi></math> are a measure of the asymptotic rate of convergence, i.e., as the iterates gets close to the solution; yet, a sequence with a good order of convergence may be very ”slow” far from the solution. Clearly, the convergence is faster when <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi></math> is larger and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi></math> is smaller. Near the solution, if the convergence rate is linear, then the error is multiplied by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi></math> at each iteration. The error reduction is squared for quadratic convergence, i.e., each iteration roughly doubles the number of significant digits. The methods that will be studied hereafter have convergence rates varying between linear and quadratic.<div class=newtheorem><p><span class=head><a id=x1-25003r19></a> <span class=cmbx-10>Example 2.19.</span></span> <span class=cmti-10>Consider the problem to minimize</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><msup><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msup></math> <span class=cmti-10>,</span> <span class=cmti-10>subject to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>x</mi><mo class=MathClass-rel>≥</mo><mn>1</mn></math> <span class=cmti-10>.</span><p><span class=cmti-10>Let the (point-to-point) algorithmic map</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> <span class=cmti-10>be defined defined as</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mn>1</mn><mo class=MathClass-close>)</mo></math> <span class=cmti-10>.</span> <span class=cmti-10>It is easily verified that the sequence obtained by applying the map</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> <span class=cmti-10>,</span> <span class=cmti-10>with any starting point, converges to the optimal solution</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mn>1</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>i.e.,</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> <span class=cmti-10>is globally convergent. For example, with</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>=</mo><mn>4</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>the algorithm generates the sequence</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mn>4</mn><mo class=MathClass-punc>,</mo><mn>2</mn><mo class=MathClass-punc>.</mo><mn>5</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>7</mn><mn>5</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>3</mn><mn>7</mn><mn>5</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>1</mn><mn>8</mn><mn>7</mn><mn>5</mn><mo class=MathClass-punc>,</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-close>}</mo></math> <span class=cmti-10>.</span> <span class=cmti-10>We have</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-close>)</mo></math> <span class=cmti-10>,</span> <span class=cmti-10>so that the limit in Definition</span> <a href=#x1-25002r24><span class=cmti-10>2.24</span></a><span class=cmti-10>is</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac></math> <span class=cmti-10>with</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi><mo class=MathClass-rel>=</mo><mn>1</mn></math> <span class=cmti-10>;</span> <span class=cmti-10>moreover, for</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi><mo class=MathClass-rel>></mo><mn>1</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>this limit is infinity. Consequently,</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-rel>→</mo><mn>1</mn></math> <span class=cmti-10>linearly with convergence ratio</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac></math> <span class=cmti-10>.</span><p><span class=cmti-10>On the other hand, consider the (point-to-point) algorithmic map</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>2</mn></mrow></msub></math> <span class=cmti-10>be defined defined as</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-punc>;</mo><mi>k</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-bin>+</mo><mfrac><mrow><mn>1</mn></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup></mrow></mfrac><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-close>)</mo></math> <span class=cmti-10>.</span> <span class=cmti-10>Again, the sequence obtained by applying</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>2</mn></mrow></msub></math> <span class=cmti-10>converges to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mn>1</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>from any starting point. However, we now have</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mfrac><mrow><mo class=MathClass-rel>|</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-rel>|</mo></mrow><mrow><mo class=MathClass-rel>|</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-rel>|</mo></mrow></mfrac><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></math> <span class=cmti-10>,</span> <span class=cmti-10>which approaches</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn></math> <span class=cmti-10>as</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></math> <span class=cmti-10>.</span> <span class=cmti-10>Hence,</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-rel>→</mo><mn>1</mn></math> <span class=cmti-10>superlinearly in this case. With</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>=</mo><mn>4</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>the algorithm generates the sequence</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mn>4</mn><mo class=MathClass-punc>,</mo><mn>2</mn><mo class=MathClass-punc>.</mo><mn>5</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>3</mn><mn>7</mn><mn>5</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>0</mn><mn>4</mn><mn>6</mn><mn>8</mn><mn>7</mn><mn>5</mn><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-close>}</mo></math> <span class=cmti-10>.</span> <span class=cmti-10>The algorithmic maps</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> <span class=cmti-10>and</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℳ</mi></mrow><mrow><mn>2</mn></mrow></msub></math> <span class=cmti-10>are illustrated on the left and right plots in Fig 1.14., respectively.</span></div><p>It should also be noted that for most algorithms, the user must set initial values for certain parameters, such as the starting point and the initial step size, as well as parameters for terminating the algorithm. Optimization procedures are often quite sensitive to these parameters, and may produce different results, or even stop prematurely, depending on their values. Therefore, it is crucial for the user to understand the principles of the algorithms used, so that he or she can select adequate values for the parameters and diagnose the reasons of a premature termination (failure).<h4 class=subsectionHead><span class=titlemark>2.9.2</span> <a id=x1-260002.9.2></a>Newton-like Algorithms for nonlinear Systems</h4><p>The fundamental approach to most iterative schemes was suggested over 300 years ago by Newton. In fact, Newton’s method is the basis for nearly all the algorithms that are described herein.<p>Suppose one wants to find the value of the variable <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> such that<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-punc>:</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> is continuously differentiable. Let us assume that one such solution exists, and denote it by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> . Let also <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> be a guess for the solution. The basic idea of Newton’s method is to approximate the nonlinear function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> by the first two terms in its Taylor series expansion about the current point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> . This yields a linear approximation for the vector function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> at the new point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> ,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mfrac><mrow><mi>∂</mi><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></mrow><mrow><mi>∂</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-open>[</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>]</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-open>[</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>]</mo></math></table><p>Using this linear approximation, and provided that the Jacobian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mfrac><mrow><mi>∂</mi><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></mrow><mrow><mi>∂</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac></math> is nonsingular, a new estimate for the solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> can be computed by solving the previous equation for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math><table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-bin>−</mo><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>(</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mfrac><mrow><mi>∂</mi><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></mrow><mrow><mi>∂</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>|</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle><msup><mrow><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>)</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle></mrow><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow></msup><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math></table><p>Letting <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi></mstyle><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>(</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mfrac><mrow><mi>∂</mi><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></mrow><mrow><mi>∂</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>|</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle><msup><mrow><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>)</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle></mrow><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow></msup><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> , we get the update <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>d</mi></mstyle></math> .<p>Of course, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> being a nonlinear function, one cannot expect that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , but there is much hope that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> be a better estimate for the root <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> than the original guess <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> . In other words, we might expect that<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mrow><mo fence=true form=prefix>‖</mo><mrow><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>≤</mo><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mrow><mo fence=true form=postfix>‖</mo><mspace class=quad width=1em></mspace><mstyle class=text><mtext>and</mtext></mstyle><mspace class=quad width=1em></mspace><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>‖</mo></mrow><mo class=MathClass-rel>≤</mo><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>‖</mo></mrow></math></table><p>If the new point is an improvement, then it makes sense to repeat the process, thereby defining a sequence of points <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-close>}</mo></math> . An algorithm implementing Newton’s method is as follows: <a id=x1-26001r1></a><div class=mdframed id=mdframed-81><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.1</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜖</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> be a termination scalar, and choose an initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> .<p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize>Solve the linear system <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>(</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mfrac><mrow><mi>∂</mi><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></mrow><mrow><mi>∂</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>|</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>)</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> .<li class=itemize>Compute the new estimate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math><li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>&lt;</mo><mi>𝜖</mi></math> , stop; otherwise, replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><p>It can be shown that the rate of convergence for Newton’s method is quadratic (see Definition <a href=#x1-25002r24>2.24</a>). Loosely speaking, it implies that each successive estimate of the solution doubles the number significant digits, which is a very desirable property for an algorithm to possess. <a id=x1-26002r21></a><div class=mdframed id=mdframed-82><p><span class=cmbx-10>Theorem</span><span class=cmbx-10> 2.21:</span> <span class=cmbx-10>Quadratic</span> <span class=cmbx-10>convergence</span> <span class=cmbx-10>for</span> <span class=cmbx-10>Newton’s</span> <span class=cmbx-10>algorithm</span><p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-punc>:</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> be continuously differentiable, and consider Newton’s algorithm defined by the map <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi mathvariant=bold-script>ℳ</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mo class=MathClass-bin>−</mo><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup><mstyle mathvariant=bold-italic><mi>ϕ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mstyle></math> . Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> be such that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , and suppose that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-close>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></math> is nonsingular. Let the starting point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> be sufficiently close to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> , so that there exist <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-punc>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-rel>></mo><mn>0</mn></math> with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mn>0</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>&lt;</mo><mn>1</mn></math> , and<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mrow><mo fence=true form=prefix>‖</mo><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mo class=MathClass-bin>−</mo><mi>T</mi></mrow></msup></mrow><mo fence=true form=postfix>‖</mo></mrow><mo class=MathClass-rel>≤</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mrow class=footnote-mark><mstyle class=label xlink:href=lecturenotes2.html#fn1x2 xlink:type=simple xmlns:xlink=http://www.w3.org/1999/xlink><sup class=textsuperscript><mi>a</mi></sup></mstyle></mrow><mstyle class=label id=x1-26003f0></mstyle><mrow class=footnote-mark><mstyle class=label id=fn1x2><sup class=textsuperscript><mi>a</mi></sup></mstyle></mrow><mstyle class=mbox><mtext>For a rectangular matrix </mtext><mstyle class=math><mi>A</mi><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><mi>n</mi><mo class=MathClass-bin>×</mo><mi>m</mi></mrow></msup></mstyle><mtext> we define the operator norm </mtext><mstyle class=math><mrow><mo fence=true form=prefix>‖</mo><mrow><mi>A</mi></mrow><mo fence=true form=postfix>‖</mo></mrow><mo class=MathClass-rel>=</mo><mstyle class=text><mtext class=textrm mathvariant=normal>sup</mtext></mstyle><mo class=MathClass-open>{</mo><mrow><mo fence=true form=prefix>‖</mo><mrow><mi>A</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo fence=true form=postfix>‖</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><mi>m</mi></mrow></msup><mstyle class=text><mtext>such that</mtext></mstyle><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo fence=true form=postfix>‖</mo></mrow><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-close>}</mo></mstyle><mtext></mtext></mstyle></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup><mo class=MathClass-open>[</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>]</mo><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>≤</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mrow></mrow></msup><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo fence=true form=postfix>‖</mo><mrow><mn>2</mn></mrow></mtd></mtr></mtable></math></table><p>for each <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> satisfying <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>≤</mo><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mn>0</mn></mrow><mo fence=true form=postfix>‖</mo></math> . Then, Newton’s algorithm converges with a quadratic rate of convergence.<div class=proof><p><span class=head><span class=cmti-10>Proof.</span></span> See [6, Theorem 8.6.5] for a proof. □</div></div><p>But can anything go wrong with Newton’s method?<p><strong><span class=cmbx-10>Lack of Global Convergence</span></strong> First and foremost, if the initial guess is not sufficiently close to the solution, i.e., within the region of convergence, Newton’s method may diverge. Said differently, Newton’s method as presented above does not have the global convergence property (see Definition <a href=#x1-25001r23>2.23</a> and Example <a href=#x1-26004r20>2.20</a> hereafter). This is because <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>)</mo><mrow><mo class=MathClass-bin>−</mo><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> may not be a valid descent direction far from the solution, and even if , a unit step size might not give a descent in <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> . Globalization strategies, which aim at correcting this latter deficiency, will be presented in <a href=#x1-280002.9.4>2.9.4</a> in the context of unconstrained optimization.<p><strong><span class=cmbx-10>Singular Jacobian Matrix</span></strong> A second difficulty occurs when the Jacobian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> becomes singular during the iteration process, since the correction defined by the Newton’s algorithm is not defined in this case. Note that the assumption in Theorem <a href=#x1-26002r21>2.21</a> guarantees that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></math> cannot be singular. But when the Jacobian matrix is singular at the solution point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> , then Newton’s method looses its quadratic convergence property.<p><strong><span class=cmbx-10>Computational Efficiency</span></strong> Finally, at each iteration, Newton’s method requires (i) that the Jacobian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> be computed, which may be difficult and/or costly especially when the expression of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> is complicated, and (ii) that a linear system be solved. The analytic Jacobian can be replaced by a finite-difference approximation, yet this is costly as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></math> additional evaluations of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> are required at each iteration. With the objective of reducing the computational effort, quasi-Newton methods generate an approximation of the Jacobian matrix, based on the information gathered from the iteration progress. To avoid solving a linear system for the search direction, variants of quasi-Newton methods also exist that generate an approximation of the inverse of the Jacobian matrix. Such methods will be described in <a href=#x1-290002.9.5>2.9.5</a> in the context of unconstrained optimization.<div class=newtheorem><p><span class=head><a id=x1-26004r20></a> <span class=cmbx-10>Example 2.20.</span></span> <span class=cmti-10>Consider the problem to find a solution to the nonlinear</span> <span class=cmti-10>equation</span><table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi class=qopname>arctan</mi><mo>⁡</mo><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>0</mn></math></table><p><span class=cmti-10>The Newton iteration sequence obtained by starting from</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>=</mo><mn>1</mn></math> <span class=cmti-10>is as</span> <span class=cmti-10>follows:</span><table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines="none none"><mtr class=hline><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mi>k</mi></mtd><mtd columnalign=center class=array><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup></mtd><mtd columnalign=center class=array><mrow><mo fence=true form=prefix>|</mo><mrow><mi>f</mi><mrow><mo fence=true form=prefix>(</mo><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mo fence=true form=postfix>|</mo></mrow></mtd></mtr><mtr class=hline><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mn>0</mn></mtd><mtd columnalign=center class=array><mn>1</mn></mtd><mtd columnalign=center class=array><mn>0</mn><mo class=MathClass-punc>.</mo><mn>7</mn><mn>8</mn><mn>5</mn><mn>3</mn><mn>9</mn><mn>8</mn></mtd></mtr><mtr><mtd columnalign=center class=array><mn>1</mn></mtd><mtd columnalign=center class=array><mo class=MathClass-bin>−</mo><mn>0</mn><mo class=MathClass-punc>.</mo><mn>5</mn><mn>7</mn><mn>0</mn><mn>7</mn><mn>9</mn><mn>6</mn></mtd><mtd columnalign=center class=array><mn>0</mn><mo class=MathClass-punc>.</mo><mn>5</mn><mn>1</mn><mn>8</mn><mn>6</mn><mn>6</mn><mn>9</mn></mtd></mtr><mtr><mtd columnalign=center class=array><mn>2</mn></mtd><mtd columnalign=center class=array><mn>0</mn><mo class=MathClass-punc>.</mo><mn>1</mn><mn>1</mn><mn>6</mn><mn>8</mn><mn>6</mn><mn>0</mn></mtd><mtd columnalign=center class=array><mn>0</mn><mo class=MathClass-punc>.</mo><mn>1</mn><mn>1</mn><mn>6</mn><mn>3</mn><mn>3</mn><mn>2</mn></mtd></mtr><mtr><mtd columnalign=center class=array><mn>3</mn></mtd><mtd columnalign=center class=array><mo class=MathClass-bin>−</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>0</mn><mn>6</mn><mn>1</mn><mn>0</mn><mn>2</mn><mn>2</mn><mo class=MathClass-bin>×</mo><mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>−</mo><mn>3</mn></mrow></msup></mtd><mtd columnalign=center class=array><mn>1</mn><mo class=MathClass-punc>.</mo><mn>0</mn><mn>6</mn><mn>1</mn><mn>0</mn><mn>2</mn><mn>2</mn><mo class=MathClass-bin>×</mo><mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>−</mo><mn>3</mn></mrow></msup></mtd></mtr><mtr><mtd columnalign=center class=array><mn>4</mn></mtd><mtd columnalign=center class=array><mn>7</mn><mo class=MathClass-punc>.</mo><mn>9</mn><mn>6</mn><mn>3</mn><mn>0</mn><mn>9</mn><mn>6</mn><mo class=MathClass-bin>×</mo><mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>−</mo><mn>1</mn><mn>0</mn></mrow></msup></mtd><mtd columnalign=center class=array><mn>7</mn><mo class=MathClass-punc>.</mo><mn>9</mn><mn>6</mn><mn>3</mn><mn>0</mn><mn>9</mn><mn>6</mn><mo class=MathClass-bin>×</mo><mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>−</mo><mn>1</mn><mn>0</mn></mrow></msup></mtd></mtr><mtr class=hline><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd><mtd><mo>̲</mo></mtd></mtr><mtr><mtd columnalign=center class=array></mtd></mtr></mtable></math></table><p><span class=cmti-10>Notice the very fast convergence to the solution</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mn>0</mn></math> <span class=cmti-10>, as</span> <span class=cmti-10>could be expected from Theorem</span> <a href=#x1-26002r21><span class=cmti-10>2.21</span></a><span class=cmti-10>. The first three iterations are represented in Fig.</span> <span class=cmti-10>1.15., on the left plot.</span><p><span class=cmti-10>However, convergence is not guaranteed for any initial guess. More precisely, it can be</span> <span class=cmti-10>shown that Newton’s method actually diverges when the initial guess is chosen such that</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-rel>|</mo><msup><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>|</mo><mo class=MathClass-rel>></mo><mi>α</mi></math> <span class=cmti-10>, with</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>.</mo><mn>3</mn><mn>9</mn><mn>1</mn><mn>7</mn><mn>4</mn><mn>5</mn><mn>2</mn><mn>0</mn><mn>0</mn><mn>2</mn><mn>7</mn><mn>0</mn><mn>7</mn></math> <span class=cmti-10>being a solution of</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>a</mi><mi>r</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>2</mn><mi>z</mi></mrow><mrow><mn>1</mn><mo class=MathClass-bin>+</mo><msup><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac></math> <span class=cmti-10>; further, the method</span> <span class=cmti-10>cycles indefinitely for</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>=</mo><mi>α</mi></math> <span class=cmti-10>.</span> <span class=cmti-10>Both these situations are illustrated in the right plot and the bottom plot of Fig. 1.15.,</span> <span class=cmti-10>respectively.</span></div><h4 class=subsectionHead><span class=titlemark>2.9.3</span> <a id=x1-270002.9.3></a>Unconstrained Optimization</h4><p>We now turn to a description of basic techniques used for iteratively solving unconstrained problems of the form:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle class=text><mtext class=textrm mathvariant=normal>min</mtext></mstyle><mspace class=thinspace width=0.3em></mspace><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mspace class=qquad width=2em></mspace><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math></table><p>Many unconstrained optimization algorithms work along the same lines. Starting from an initial point, a direction of movement is determined according to a fixed rule, and then a move is made in that direction so that the objective function value is reduced; at the new point, a new direction is determined and the process is repeated. The main difference between these algorithms rest with the rule by which successive directions of movement are selected. A distinction is usually made between those algorithms which determine the search direction <span class=cmti-10>without</span> using gradient information (gradient-free methods), and those using gradient (and higher-order derivatives) information (gradient-based methods). Here, we shall focus our attention on the latter class of methods, and more specifically on Newton-like algorithms.<p>Throughout this subsection, we shall assume that the objective function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> is twice continuously differentiable. By theorem <a href=#x1-14006r3>2.3</a>, a necessary condition for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> to be a local minimum of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> is <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> . Hence, the idea is to devise an iterative scheme that finds a point satisfying the foregoing condition. Following the techniques discussed earlier in <a href=#x1-260002.9.2>2.9.2</a>, this can be done by using a Newton-like algorithm, with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ϕ</mi></mstyle></math> corresponding to the gradient <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi></math> of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ϕ</mi></mrow></msup></mstyle><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></math> to its Hessian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi></math> .<p>At each iteration, a new iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> is obtained such that the linear approximation to the gradient at that point is zero,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≈</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-open>[</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>]</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math></table><p>The linear approximation yields the Newton search direction:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>)</mo><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math></table><p>As discussed in <a href=#x1-260002.9.2>2.9.2</a>, if it converges, Newton’s method exhibits a quadratic rate of convergence when the Hessian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> is nonsingular at the solution point. However, since the Newton iteration is based on finding a zero of the gradient vector, there is no guarantee that the step will move towards a local minimum, rather than a saddle point or even a maximum. To preclude this, the Newton steps should be taken downhill, i.e., the following descent condition should be satisfied at each iteration,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>&lt;</mo><mn>0</mn></math></table><p>Interestingly enough, with the Newton direction iteration, the descent condition becomes<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>)</mo><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mn>0</mn></math></table><p>That is, a sufficient condition to obtain a descent direction at <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> is that the Hessian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> be positive definite. Moreover, if <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> is positive definite at a local minimizer <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , then the Newton iteration converges to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> when started sufficiently close to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> . (Recall that, by Theorem <a href=#x1-14021r8>2.8</a>, positive definiteness of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> is a sufficient condition for a local minimum of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> to be a strict local minimum.)<p>We now discuss two important improvements to Newton’s method, which are directly related to the issues discussed in Subsection <a href=#x1-260002.9.2>2.9.2</a>, namely (i) the lack of global convergence, and (ii) computational efficiency.<h4 class=subsectionHead><span class=titlemark>2.9.4</span> <a id=x1-280002.9.4></a>Globalization Strategies</h4><p>Up to this point, the development has focused on the application of Newton’s method. However, even in the simplest one-dimensional applications, Newton’s method has deficiencies (see, e.g., Example <a href=#x1-26004r20>2.20</a>). Methods for correcting global convergence deficiencies are referred to as globalization strategies. It should be stressed than an efficient globalization strategy should only alter the iterates when a problem is encountered, but it should not impede the ultimate behavior of the method, i.e., the quadratic convergence of a Newton’s method should be retained.<p>In unconstrained optimization, one can detect problems in a very simple fashion, by monitoring whether the next iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> satisfies a descent condition with respect to the actual iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , e.g., <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> . Then, either one of two globalization strategies can be used to correct the Newton step. The first strategy, known as line search method, is to alter the magnitude of the step; the second one, known as trust region method, is to modify both the step magnitude and direction. We shall only concentrate on the former class of globalization strategies subsequently.<p>A line search method proceeds by replacing the <span class=cmti-10>full</span> Newton step <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> with<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math></table><p>where the step-length <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi><mo class=MathClass-rel>≥</mo><mn>0</mn></math> is chosen such that the objective function is reduced,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math></table><p>Clearly, the optimal choice for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi></math> would be <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>α</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mstyle class=text><mtext class=textrm mathvariant=normal>argmin</mtext></mstyle><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>{</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mi>l</mi><mo class=MathClass-open>(</mo><mi>α</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mspace class=thinspace width=0.3em></mspace><mspace class=quad width=1em></mspace><mi>α</mi><mo class=MathClass-rel>≥</mo><mn>0</mn><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>}</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle></math> . The resulting minimization problem can be solved by any one-dimensional <span class=cmti-10>exact</span> minimization technique (e.g., Newton’s method itself). However, such techniques are costly in the sense that they often require many iterations to converge and, therefore, many function (or even gradient) evaluations.<p>In response to this, most modern algorithms implement so-called inexact line search criteria, which aim to find a step-length giving an ”acceptable” decrease in the objective function. Note that sacrificing accuracy, we might impair the convergence of the overall algorithm that iteratively employs such a line search. However, by adopting a line search that guarantees a sufficient degree of descent in the objective function, the convergence of the overall algorithm can still be established.<p>We now describe one popular definition of an acceptable step-length known as Armijo’s rule. Other popular approaches are the quadratic and cubic fit techniques, as well as Wolfe’s and Glodstein’s tests. Armijo’s rule is driven by two parameters <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn><mo class=MathClass-rel>&lt;</mo><msub><mrow><mi>κ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-rel>&lt;</mo><mn>1</mn></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>κ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-rel>></mo><mn>1</mn></math> , which respectively manage the acceptable step-length from being too large or too small (Typical vales are <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>κ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-rel>=</mo><mn>0</mn><mo class=MathClass-punc>.</mo><mn>2</mn></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>κ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-rel>=</mo><mn>2</mn></math> ). Define the line search function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>l</mi><mo class=MathClass-open>(</mo><mi>α</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> , for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi><mo class=MathClass-rel>≥</mo><mn>0</mn></math> , and consider the modified first-order approximation <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mi>l</mi></mrow><mo accent=true>^</mo></mover><mo class=MathClass-open>(</mo><mi>α</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>l</mi><mo class=MathClass-open>(</mo><mn>0</mn><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><msub><mrow><mi>κ</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>α</mi><msup><mrow><mi>l</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class=MathClass-open>(</mo><mn>0</mn><mo class=MathClass-close>)</mo></math> . A step-length <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-rel>∈</mo><mo class=MathClass-open>(</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-close>)</mo></math> is deemed acceptable if the following conditions hold:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right><mi>l</mi><mo class=MathClass-open>(</mo><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mover accent=true><mrow><mi>l</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-open>(</mo><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=right><mi>l</mi><mo class=MathClass-open>(</mo><msub><mrow><mi>κ</mi></mrow><mrow><mn>2</mn></mrow></msub><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≥</mo><mover accent=true><mrow><mi>l</mi></mrow><mo accent=true>^</mo></mover><mo class=MathClass-open>(</mo><msub><mrow><mi>κ</mi></mrow><mrow><mn>2</mn></mrow></msub><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo></mtd></mtr></mtable></math></table><p>The first condition prevents the step-length <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover></math> from being too large, whereas the second condition prevents <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mi>α</mi></mrow><mo accent=true>¯</mo></mover></math> from being too small. The acceptable region defined by the Armijo’s rule is shown in Fig. 1.16. below.<h4 class=subsectionHead><span class=titlemark>2.9.5</span> <a id=x1-290002.9.5></a>Recursive Updates</h4><p>Another limitation of Newton’s method when applied to unconstrained optimization problems is that the Hessian matrix of the objective function is needed at each iteration, then a linear system must be solved for obtaining the search direction. For many applications, this can be a costly computational burden. In response to this, quasi-Newton methods attempt to construct this information recursively. However, by so doing, the quadratic rate of convergence is lost.<p>The basic idea for many quasi-Newton methods is that two successive iterates <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> together with the corresponding gradients <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-punc>,</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></math> , yield curvature information by means of the first-order approximation relation<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>o</mi><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>(</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mrow><mo fence=true form=prefix>‖</mo><mrow><mstyle mathvariant=bold><mi>d</mi></mstyle></mrow><mo fence=true form=postfix>‖</mo></mrow><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>)</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> . In particular, given <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></math> linearly independent iteration increments <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>δ</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>δ</mi></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>−</mo><mn>1</mn></mrow></math> an approximation of the Hessian matrix can be obtained as<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≈</mo><mo class=MathClass-open>[</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mspace class=thinspace width=0.3em></mspace><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mo class=MathClass-close>]</mo><msup><mrow><mo class=MathClass-open>[</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mn>0</mn></mrow></msup><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mspace class=thinspace width=0.3em></mspace><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mo class=MathClass-close>]</mo><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow></math></table><p>or for the inverse Hessian matrix as<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≈</mo><mo class=MathClass-open>[</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mspace class=thinspace width=0.3em></mspace><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mo class=MathClass-close>]</mo><msup><mrow><mo class=MathClass-open>[</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mn>0</mn></mrow></msup><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mspace class=thinspace width=0.3em></mspace><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>−</mo><mn>1</mn></mrow><mo class=MathClass-close>]</mo><mrow><mo class=MathClass-bin>−</mo><mn>1</mn></mrow></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math><p>Note that when the objective function is quadratic, the previous relations are exact. Many interesting quasi-Newton methods use similar ways, although more sophisticated, to construct an approximate Hessian matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup></math> that progressively approaches the inverse Hessian. One of the most popular class of quasi-Newton methods (known as the Broyden family) proceeds as follows:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup></mtd><mtd columnalign=left><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-bin>+</mo><mfrac><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac><mo class=MathClass-bin>−</mo><mfrac><mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac><mo class=MathClass-bin>+</mo></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mo class=MathClass-bin>+</mo><mi>ξ</mi><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mfrac><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mfrac></mrow><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-bin>−</mo><mfrac><mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac><mo fence=true form=postfix>)</mo><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mfrac><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mfrac></mrow></mrow></mrow></msup><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>−</mo><mfrac><mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn><mo class=MathClass-rel>≤</mo><mi>ξ</mi><mo class=MathClass-rel>≤</mo><mn>1</mn></math> . It is easily seen that when supplemented with a line search strategy, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>&lt;</mo><mn>0</mn></math> at each <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi></math> , and hence the Hessian matrix approximations are guaranteed to exist. Moreover, it can be shown that the successive approximates remain positive definite provided that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mn>0</mn></mrow></msup></math> is itself positive definite.<p>By setting <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ξ</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , the previous equation yields the Davidon-Fletcher-Powell (DFP) method, which is historically the first quasi-Newton method, while setting <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ξ</mi><mo class=MathClass-rel>=</mo><mn>1</mn></math> gives the Broyden-Fletcher-Goldfard-Shanno (BFGS) method, for which there is substantial evidence that it is the best general purpose quasi-Newton method currently known.<h4 class=subsectionHead><span class=titlemark>2.9.6</span> <a id=x1-300002.9.6></a>Summary</h4><p>A Newton-like algorithm including both a line search method (Armijo’s rule) and Hessian recursive update (DFP update) is as follows: <a id=x1-30001r2></a><div class=mdframed id=mdframed-83><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.2</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜖</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> be a termination scalar, and choose an initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-rel>∈</mo><msup><mrow><mi>R</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> and a symmetric, positive definite matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>×</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> . Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize><span class=cmti-10>Search Direction</span> - <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> .<li class=itemize><span class=cmti-10>Line Search</span> - Find a step <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msup></math> satisfying Armijo’s conditions.<li class=itemize><span class=cmti-10>Update</span> - Compute the new estimates:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><msup><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right></mtd><mtd columnalign=left><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-bin>+</mo><mfrac><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac><mo class=MathClass-bin>−</mo><mfrac><mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle></mrow><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mfrac></mtd></mtr></mtable></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math><li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mrow><mo fence=true form=prefix>‖</mo><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></mrow><mo fence=true form=postfix>‖</mo><mo class=MathClass-rel>&lt;</mo><mi>𝜖</mi></math> , stop; otherwise, replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><p>The standard unconstrained optimization algorithm in MATLAB (i.e. the function <span class=cmti-10>fminunc</span>) is an implementation of quasi-Newton’s method, with DFP or BFGS update, and a line search strategy.<div class=newtheorem><p><span class=head><a id=x1-30002r21></a> <span class=cmbx-10>Example 2.21.</span></span> <span class=cmti-10>Consider the problem to find a minimum to Rosenbrock’s</span> <span class=cmti-10>function</span><table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mn>1</mn><mo class=MathClass-bin>−</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mrow><mn>2</mn></mrow></msup><mo class=MathClass-bin>+</mo><mi>c</mi><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-bin>−</mo><msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mrow><mn>2</mn></mrow></msup></math></table><p><span class=cmti-10>for</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><mn>2</mn></mrow></msup></math> <span class=cmti-10>with</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>c</mi><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mn>1</mn><mn>0</mn><mn>5</mn></math> <span class=cmti-10>.</span> <span class=cmti-10>We solved this problem using the function</span> fminunc <span class=cmti-10>.</span><p><span class=cmti-10>The results are shown in Fig. 1.17. Observe the slow</span> <span class=cmti-10>convergence of the iterates far from the optimal solution</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-rel>=</mo><msup><mrow><mo class=MathClass-open>(</mo><mspace class=thinspace width=0.3em></mspace><mn>1</mn><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-punc>,</mo><mspace class=thinspace width=0.3em></mspace><mn>1</mn><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-close>)</mo></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></math> <span class=cmti-10>but the very fast convergence</span> <span class=cmti-10>in the vicinity of</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> <span class=cmti-10>.</span></div><h4 class=subsectionHead><span class=titlemark>2.9.7</span> <a id=x1-310002.9.7></a>Constrained Nonlinear Optimization</h4><p>In this subsection, we turn our attention to algorithms for iteratively solving constrained problems of the form:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle class=text><mtext class=textrm mathvariant=normal>min</mtext></mstyle><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>;</mo><mspace class=quad width=1em></mspace><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-rel>⊂</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math></table><p>Many modern deterministic algorithms for constrained NLP problems are based on the (rather natural) principle that, instead of solving a difficult problem directly, one had better solve a sequence of simpler, but related, subproblems, which converges to a solution of the original problem either in a finite number of steps or in the limit. Working along these lines, two classes of algorithms can be distinguished for solution of NLP problems with equality and/or inequality constraints. On the one hand, penalty function and interior-point methods consist of solving the problem as a sequence of unconstrained problems (or problems with simple constraints), so that algorithms for unconstrained optimization can be used. These methods, which do not rely on the KKT theory described earlier in <a href=#x1-150002.6>2.6</a> through <a href=#x1-210002.8>2.8</a>, shall be briefly presented in <a href=#x1-320002.9.8>2.9.8</a> and <a href=#x1-330002.9.9>2.9.9</a>. On the other hand, Newton-like methods solve NLP problems by attempting to find a point satisfying the necessary conditions of optimality (KKT conditions in general). Sequential quadratic programming (SQP), which shall be presented in <a href=#x1-340002.9.10>2.9.10</a>, represents one such class of methods.<h4 class=subsectionHead><span class=titlemark>2.9.8</span> <a id=x1-320002.9.8></a>Penalty Function Methods</h4><p>Methods using penalty functions transform a constrained problem into a single unconstrained problem or a sequence of unconstrained problems. This is done by placing the constraints into the objective function via a penalty parameter in a way that penalizes any violation of the constraints. To illustrate it, consider the NLP problem:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><mi class=qopname>min</mi><mo>⁡</mo></mtd><mtd columnalign=left class=array><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr><mtr><mtd columnalign=center class=array></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr><mtr><mtd columnalign=center class=array></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi><mo class=MathClass-rel>⊂</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-punc>:</mo><mi>X</mi><mo class=MathClass-rel>→</mo><mi>ℝ</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-punc>:</mo><mi>X</mi><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></msup></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-punc>:</mo><mi>X</mi><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></msup></math> are defined on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> .<p>In general, a suitable penalty function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> for the minimization problem is defined by:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mi>ϕ</mi><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>]</mo></mrow><mo class=MathClass-bin>+</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></munderover><mi>ψ</mi><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>]</mo></mrow></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ψ</mi></math> are continuous functions satisfying the conditions:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mrow><mo fence=true form=prefix>{</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=left class=array><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>0</mn></mtd><mtd columnalign=left class=array><mstyle class=text><mtext> if </mtext></mstyle><mi>z</mi><mo class=MathClass-rel>≤</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign=left class=array><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>></mo><mn>0</mn></mtd><mtd columnalign=left class=array><mstyle class=text><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow><mo fence=true form=postfix></mo></mrow><mspace class=quad width=1em></mspace><mstyle class=text><mtext> and </mtext></mstyle><mspace class=quad width=1em></mspace><mrow><mo fence=true form=prefix>{</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=left class=array><mi>ψ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>0</mn></mtd><mtd columnalign=left class=array><mstyle class=text><mtext> if </mtext></mstyle><mi>z</mi><mo class=MathClass-rel>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign=left class=array><mi>ψ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>></mo><mn>0</mn></mtd><mtd columnalign=left class=array><mstyle class=text><mtext> otherwise</mtext></mstyle></mtd></mtr></mtable></mrow><mo fence=true form=postfix></mo></mrow></math></table><p>Typically, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ψ</mi></math> are of the forms<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><msup><mrow><mo class=MathClass-open>(</mo><mi class=qopname>max</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mi>z</mi><mo class=MathClass-close>}</mo><mo class=MathClass-close>)</mo></mrow><mrow><mi>p</mi></mrow></msup><mspace class=quad width=1em></mspace><mstyle class=text><mtext> and </mtext></mstyle><mspace class=quad width=1em></mspace><mi>ψ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-rel>|</mo><mi>z</mi><msup><mrow><mo class=MathClass-rel>|</mo></mrow><mrow><mi>p</mi></mrow></msup></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi></math> a positive integer (taking <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>p</mi><mo class=MathClass-rel>≥</mo><mn>2</mn></math> provides continuously differentiable penalty functions). The function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> is referred to as the <span class=cmti-10>auxiliary function</span>.<div class=newtheorem><p><span class=head><a id=x1-32001r22></a> <span class=cmbx-10>Example 2.22.</span></span> <span class=cmti-10>Consider the problem to minimize</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>x</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>subject to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mn>2</mn><mo class=MathClass-rel>≤</mo><mn>0</mn></math> <span class=cmti-10>.</span> <span class=cmti-10>It is immediately evident that the optimal solution lies at the point</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mn>2</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>and has objective value</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>2</mn></math> <span class=cmti-10>.</span><p><span class=cmti-10>Now, consider the penalty problem to minimize</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mi>μ</mi><mi class=qopname>max</mi><mo>⁡</mo><msup><mrow><mo class=MathClass-open>{</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-close>}</mo></mrow><mrow><mn>2</mn></mrow></msup></math> <span class=cmti-10>in</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ℝ</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>where</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>is a large number. Note first that for any</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>the auxiliary function is convex since it is sum of convex functions. Thus, a</span> <span class=cmti-10>necessary and sufficient condition for optimality is that the gradient of</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo></math> <span class=cmti-10>be equal to zero, yielding</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-rel>=</mo><mn>2</mn><mo class=MathClass-bin>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn><mi>μ</mi></mrow></mfrac></math> <span class=cmti-10>.</span> <span class=cmti-10>Thus, the solution of the penalty problem can be made arbitrarily close to the</span> <span class=cmti-10>solution of the original problem by choosing</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>sufficiently large. Moreover,</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>2</mn><mo class=MathClass-bin>−</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>4</mn><mi>μ</mi></mrow></mfrac></math> <span class=cmti-10>,</span> <span class=cmti-10>which can also be made arbitrarily close to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-close>)</mo></math> <span class=cmti-10>by taking</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>sufficiently large. These considerations are illustrated in Fig. 1.18. below.</span></div><p>The conclusions of Example <a href=#x1-32001r22>2.22</a> that the solution of the penalty problem can be made arbitrarily close to the solution of the original problem, and the optimal auxiliary function value arbitrarily close to the optimal objective value, by choosing sufficiently large, is formalized in the following: <a id=x1-32002r22></a><div class=mdframed id=mdframed-84><p><span class=cmbx-10>Theorem</span><span class=cmbx-10> 2.22</span><p>Consider a general NLP problem, where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle></math> are continuous functions on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> is a nonempty set in <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> . Suppose that the NLP problem has a feasible solution, and let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>α</mi></math> be a continuous penalty function. Suppose further that for each <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> there exists a solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-rel>∈</mo><mi>X</mi></math> to the problem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=qopname>min</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo></math> , and that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>}</mo></math> is contained in a compact subset of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> . Then,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=qopname>min</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo><mo class=MathClass-rel>=</mo><munder class=msub><mrow><mi class=qopname>sup</mi><mo>⁡</mo></mrow><mrow><mi>μ</mi><mo class=MathClass-rel>≥</mo><mn>0</mn></mrow></munder><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><munder class=msub><mrow><mi class=qopname>lim</mi><mo>⁡</mo></mrow><mrow><mi>μ</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></mrow></munder><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo></math> . Furthermore, the limit <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> of any convergent subsequence of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>}</mo></math> is an optimal solution to the original problem and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>→</mo><mn>0</mn></math> as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></math> .<div class=proof><p><span class=head><span class=cmti-10>Proof.</span></span> See [6, Theorem 9.2.2] for a proof. □</div></div><p>Note that the assumption that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> is compact is necessary, for it possible that the optimal objective values of the original and penalty problems are not equal otherwise. Yet, this assumption is not very restrictive in most practical cases as the variables usually lie between finite upper and lower bounds. Note also that no restriction is imposed on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle></math> other than continuity. However, the application of an efficient solution procedure for the (unconstrained) auxiliary problems may impose additional restriction on these functions (see <a href=#x1-270002.9.3>2.9.3</a>).<p>Under the conditions that (i) <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ψ</mi></math> are continuously differentiable, and (ii) <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover></math> is a regular point the solution to the penalty problem can be used to recover the Lagrange multipliers associated with the constraints at optimality. In the particular case where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi><mo class=MathClass-rel>=</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> , we get<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right><msubsup><mrow><mi>ν</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>μ</mi></mrow></msubsup></mtd><mtd columnalign=left><mo class=MathClass-rel>=</mo><mi>μ</mi><msup><mrow><mi>ϕ</mi></mrow><mrow><mi>′</mi></mrow></msup><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>μ</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mo fence=true form=postfix>]</mo><mspace class=quad width=1em></mspace><mi class=MathClass-op>∀</mi><mo>⁡</mo><mi>i</mi><mo class=MathClass-rel>∈</mo><mi mathvariant=bold-script>𝒜</mi><mo class=MathClass-open>(</mo><mover accent=false class=mml-overline><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mo accent=true>¯</mo></mover><mo class=MathClass-close>)</mo></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right><msubsup><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>μ</mi></mrow></msubsup></mtd><mtd columnalign=left><mo class=MathClass-rel>=</mo><mi>μ</mi><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>μ</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mo fence=true form=postfix>]</mo><mspace class=quad width=1em></mspace><mi class=MathClass-op>∀</mi><mo>⁡</mo><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>,</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-punc>,</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mtd></mtr></mtable></math></table><p>The larger <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> , the better the approximation of the Lagrange multipliers:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-rel>→</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mstyle class=text><mtext> and </mtext></mstyle><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-rel>→</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mstyle class=text><mtext> as </mtext></mstyle><mi>μ</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></math></table><div class=newtheorem><p><span class=head><a id=x1-32003r23></a> <span class=cmbx-10>Example 2.23.</span></span> <span class=cmti-10>Consider the same problem as in Example 1.71. The auxiliary</span> <span class=cmti-10>function</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>α</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mi>μ</mi><mi class=qopname>max</mi><mo>⁡</mo><msup><mrow><mo class=MathClass-open>{</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-close>}</mo></mrow><mrow><mn>2</mn></mrow></msup></math> <span class=cmti-10>being continuously differentiable, the Lagrange multiplier associated to the inequality</span> <span class=cmti-10>constraint</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mn>2</mn><mo class=MathClass-rel>≤</mo><mn>0</mn></math> <span class=cmti-10>can be recovered as</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ν</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-rel>=</mo><mn>2</mn><mi>μ</mi><mi class=qopname>max</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-close>}</mo></math> <span class=cmti-10>(assuming</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> <span class=cmti-10>).</span> <span class=cmti-10>Note that the exact value of the Lagrange multiplier is obtained for each</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> <span class=cmti-10>here, because</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi></math> <span class=cmti-10>is a linear constraint.</span></div><p>From a computational viewpoint, superlinear convergence rates might be achievable, in principle, by applying Newton’s method (or its variants such as quasi-Newton methods). Yet, one can expect ill-conditioning problems when <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> is taken very large in the penalty problem. With a large <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> , more emphasis is placed on feasibility, and most procedures for unconstrained optimization will move quickly towards a feasible point. Even though this point may be far from the optimum, both slow convergence and premature termination can occur due to very small step size and finite precision computations (round-off errors).<p>As a result of the above mentioned difficulties associated with large penalty parameters, most algorithms using penalty functions employ a sequence of increasing penalty parameters. With each new value of the penalty parameter, an optimization technique is employed, starting with the optimal solution corresponding to the previously chosen parameters value. Such an approach is often referred to as sequential unconstrained minimization (SUM) technique. This way, a sequence of infeasible points is typically generated, whose limit is an optimal solution to the original problem (hence the term <span class=cmti-10>exterior penalty function</span> <span class=cmti-10>approach</span>).<p>To conclude our discussion on the penalty function approach, we give an algorithm to solve a general NLP problem, where the penalty function used are of the form specified by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ψ</mi></math> <a id=x1-32004r3></a><div class=mdframed id=mdframed-85><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.3</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜖</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> be a termination scalar, and choose an initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> , a penalty parameter <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>></mo><mn>0</mn></math> , and a scalar <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi><mo class=MathClass-rel>></mo><mn>1</mn></math> . Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize>Starting with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , get a solution to the problem:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>∈</mo><mi class=qopname>arg</mi><mo>⁡</mo><mi class=qopname>min</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>{</mo><mrow><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></mrow><mo fence=true form=postfix>}</mo></mrow></math></table><li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>α</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mi>𝜖</mi></math> , stop; otherwise, let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup><mo class=MathClass-rel>=</mo><mi>β</mi><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup></math> , replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><h4 class=subsectionHead><span class=titlemark>2.9.9</span> <a id=x1-330002.9.9></a>Interior-Point Methods</h4><p>Similar to penalty functions, <span class=cmti-10>barrier functions</span> can also be used to transform a constrained problem into an unconstrained problem (or into a sequence of unconstrained problems). These functions act as a barrier and prevent the iterates from leaving the feasible region. If the optimal solution occurs at the boundary of the feasible domain, the procedure moves from the interior to the boundary of the domain, hence the name interior-point methods. To illustrate these methods, consider the NLP problem:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><munder class=msub><mrow><mi class=qopname>min</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></munder></mtd><mtd columnalign=left class=array><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr><mtr><mtd columnalign=center class=array></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> is a subset of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> , and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-punc>:</mo><mi>X</mi><mo class=MathClass-rel>→</mo><mi>ℝ</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-punc>:</mo><mi>X</mi><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></msup></math> are continuous on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> . Note that equality constraints, if any, should be accommodated within the set <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> . (In the case of affine equality constraints, one can possibly eliminate them after solving for some variables in terms of the others, thereby reducing the dimension of the problem.) The reason why this treatment is necessary is because barrier function methods require the set <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> to be <strong><span class=cmbx-10>nonempty</span></strong>; this would obviously be not possible if the equality constraints <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> were accommodated within the set of inequalities as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≥</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> .<p>A barrier problem formulates as:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><munder class=msub><mrow><mi class=qopname>inf</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>μ</mi></mstyle></mrow></munder></mtd><mtd columnalign=left class=array><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=left class=array><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi class=qopname>inf</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo></math> . Ideally, the barrier function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>b</mi></math> should take value zero on the region <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> , and value <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>∞</mi></math> on its boundary. This would guarantee that the iterates do not leave the domain <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> provided the minimization problem started at an interior point. However, this discontinuity poses serious difficulties for any computational procedure. Therefore, this ideal construction of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>b</mi></math> is replaced by the more realistic requirement that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>b</mi></math> be nonnegative and continuous over the region <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> and approach infinity as the boundary is approached from the interior:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mi>ϕ</mi><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>]</mo></mrow></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> is a continuous function over <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mi>z</mi><mo class=MathClass-punc>:</mo><mi>z</mi><mo class=MathClass-rel>&lt;</mo><mn>0</mn><mo class=MathClass-close>}</mo></math> that satisfies the conditions<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mrow><mo fence=true form=prefix>{</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=left class=array><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≥</mo><mn>0</mn><mspace class=quad width=1em></mspace><mstyle class=text><mtext> if </mtext></mstyle><mi>z</mi><mo class=MathClass-rel>&lt;</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign=left class=array><munder class=msub><mrow><mi class=qopname>lim</mi><mo>⁡</mo></mrow><mrow><mi>z</mi><mo class=MathClass-rel>→</mo><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>−</mo></mrow></msup></mrow></munder><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>+</mo><mi>∞</mi></mtd></mtr></mtable></mrow><mo fence=true form=postfix></mo></mrow></math></table><p>In particular, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mspace class=thinspace width=0.3em></mspace><mi>b</mi></math> approaches the ideal barrier function described above as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> approaches zero.<p>Typically barrier functions are<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mfrac><mrow><mn>1</mn></mrow><mrow><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow></mfrac><mspace class=quad width=1em></mspace><mstyle class=text><mtext> or </mtext></mstyle><mspace class=quad width=1em></mspace><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mi class=qopname>ln</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>[</mo><mrow><mi class=qopname>min</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>{</mo><mrow><mn>1</mn><mo class=MathClass-punc>,</mo><mo class=MathClass-bin>−</mo><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>}</mo></mrow></mrow><mo fence=true form=postfix>]</mo></mrow></math></table><p>The following barrier function, known as Frisch’s logarithmic barrier function, is also widely used<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mi class=qopname>ln</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>[</mo><mrow><mo class=MathClass-bin>−</mo><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>]</mo></mrow></math></table><p>Actually the Frisch’s logarithmic barrier <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi><mo class=MathClass-open>(</mo><mi>z</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mi class=qopname>ln</mi><mo>⁡</mo><mo class=MathClass-open>(</mo><mo class=MathClass-bin>−</mo><mi>z</mi><mo class=MathClass-close>)</mo></math> does not satisfy the nonnegativity requirement for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>z</mi><mo class=MathClass-rel>&lt;</mo><mo class=MathClass-bin>−</mo><mn>1</mn></math> . However the requirement on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> can be relaxed and it is sufficient that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> be positive close to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>z</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> .<p>The function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> is referred to as the <span class=cmti-10>auxiliary function</span>.<p>Given <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> , evaluating <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle class=text><mtext class=textrm mathvariant=normal>inf</mtext></mstyle><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo></math> seems no simpler than solving the original problem because of the constraint <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> . However, starting the optimization from a point in the region <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>S</mi><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo><mo class=MathClass-bin>∩</mo><mi>X</mi></math> yields an optimal point in <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>S</mi></math> , even when the constraint <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> is ignored. This is because <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>b</mi></math> approaches infinity as the iterates approach the boundary of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> from within <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>S</mi></math> , hence preventing them from leaving the set <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>S</mi></math> . This is formalized in the following: <a id=x1-33001r23></a><div class=mdframed id=mdframed-86><p><span class=cmbx-10>Theorem</span><span class=cmbx-10> 2.23</span><p>Consider a NLP problem with inequality constraints , where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle></math> are continuous functions on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi></math> is a nonempty closed set in <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> . Suppose that the minimization problem has an optimal solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> with the property that, given any neighborhood <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi mathvariant=bold-script>ℬ</mi></mrow><mrow><mi>η</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> around <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> , there exists an <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-bin>∩</mo><msub><mrow><mi mathvariant=bold-script>ℬ</mi></mrow><mrow><mi>η</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> such that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> . Suppose further that for each <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> , there exists a solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-rel>∈</mo><mi>X</mi></math> to the problem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=qopname>min</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo></math> . Then,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=qopname>min</mi><mo>⁡</mo><mo class=MathClass-open>{</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi><mo class=MathClass-close>}</mo><mo class=MathClass-rel>=</mo><munder class=msub><mrow><mi class=qopname>lim</mi><mo>⁡</mo></mrow><mrow><mi>μ</mi><mo class=MathClass-rel>→</mo><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>+</mo></mrow></msup></mrow></munder><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><munder class=msub><mrow><mi class=qopname>inf</mi><mo>⁡</mo></mrow><mrow><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></mrow></munder><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜃</mi><mo class=MathClass-open>(</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo></math> . Furthermore, the limit of any convergent subsequence of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>}</mo></math> is an optimal solution to the original problem, and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>→</mo><mn>0</mn></math> as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>→</mo><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>+</mo></mrow></msup></math> .<div class=proof><p><span class=head><span class=cmti-10>Proof.</span></span> See [6, Theorem 9.4.3] for a proof. □</div></div><p>Under the conditions that (i) <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ϕ</mi></math> are continuously differentiable, and (ii) <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> is a regular point, the solution to the barrier function problem can be used to recover the Lagrange multipliers associated with the constraints at optimality. In the particular case where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>X</mi><mo class=MathClass-rel>=</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> , we get:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msubsup><mrow><mi>ν</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>μ</mi></mrow></msubsup><mo class=MathClass-rel>=</mo><mi>μ</mi><msup><mrow><mi>ϕ</mi></mrow><mrow><mi>′</mi></mrow></msup><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=normal><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>μ</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mrow></mrow><mo fence=true form=postfix>]</mo><mspace class=quad width=1em></mspace><mi class=MathClass-op>∀</mi><mo>⁡</mo><mi>i</mi><mo class=MathClass-rel>∈</mo><mi mathvariant=bold-script>𝒜</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math></table><p>The approximation of the Lagrange multipliers, gets better as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> gets closer to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn></math> ,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>μ</mi></mrow><mo class=MathClass-rel>→</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mstyle class=text><mtext> as </mtext></mstyle><mi>μ</mi><mo class=MathClass-rel>→</mo><msup><mrow><mn>0</mn></mrow><mrow><mo class=MathClass-bin>+</mo></mrow></msup></math></table><div class=newtheorem><p><span class=head><a id=x1-33002r24></a> <span class=cmbx-10>Example 2.24.</span></span> <span class=cmti-10>Consider the problem to minimize</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>x</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>subject to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mn>2</mn><mo class=MathClass-rel>≤</mo><mn>0</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>the solution of which lies at the point</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-rel>=</mo><mn>2</mn></math> <span class=cmti-10>with objective value</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>2</mn></math> <span class=cmti-10>.</span> <span class=cmti-10>Now, consider the barrier function problem to minimize</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi>x</mi><mo class=MathClass-bin>−</mo><mfrac><mrow><mi>μ</mi></mrow><mrow><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi></mrow></mfrac></math> <span class=cmti-10>in</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>ℝ</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>where</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>is a large number. Note first that for any</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>,</span> <span class=cmti-10>the auxiliary function is convex</span> <span class=footnote-mark><a href=lecturenotes2.html#fn1x2><sup class=textsuperscript>1</sup></a> </span><a id=x1-33003f1></a> <span class=footnote-mark><a id=fn1x2><sup class=textsuperscript>1</sup></a> </span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mfrac><mrow><mi>μ</mi></mrow><mrow><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi></mrow></mfrac></math> <span class=cmr-8>is a concave function on the convex set</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>S</mi><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-open>{</mo><mi>x</mi><mo class=MathClass-rel>∈</mo><mi>ℝ</mi><mo class=MathClass-punc>,</mo><mi>x</mi><mo class=MathClass-rel>≥</mo><mn>2</mn><mo class=MathClass-close>}</mo></math> <span class=cmr-8>,</span> <span class=cmr-8>therefore</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-bin>−</mo><mfrac><mrow><mi>μ</mi></mrow><mrow><mn>2</mn><mo class=MathClass-bin>−</mo><mi>x</mi></mrow></mfrac></math> <span class=cmr-8>is convex and thus</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo></math> <span class=cmr-8>is sum of convex functions.</span> <span class=cmti-10>.</span> <span class=cmti-10>Thus, a necessary and sufficient condition for optimality is that the gradient of</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo></math> <span class=cmti-10>be equal to zero, yielding</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-rel>=</mo><mn>2</mn><mo class=MathClass-bin>+</mo><msqrt><mrow><mi>μ</mi></mrow></msqrt></math> <span class=cmti-10>(assuming</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> <span class=cmti-10>).</span> <span class=cmti-10>Thus, the solution of the penalty problem can be made arbitrarily close to the</span> <span class=cmti-10>solution of the original problem by choosing</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>sufficiently close to zero. Moreover,</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>2</mn><mo class=MathClass-bin>+</mo><mn>2</mn><msqrt><mrow><mi>μ</mi></mrow></msqrt></math> <span class=cmti-10>,</span> <span class=cmti-10>which can also be made arbitrarily close to</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msup><mo class=MathClass-close>)</mo></math> <span class=cmti-10>by taking</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> <span class=cmti-10>sufficiently close to zero. These considerations are illustrated in Fig. 1.19. below.</span> <span class=cmti-10>Regarding the Lagrange multiplier associated to the inequality constraint</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi><mo class=MathClass-open>(</mo><mi>x</mi><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mi>x</mi><mo class=MathClass-bin>+</mo><mn>2</mn><mo class=MathClass-rel>≤</mo><mn>0</mn></math> <span class=cmti-10>,</span> <span class=cmti-10>the objective and constraint functions being continuously differentiable, an approximate</span> <span class=cmti-10>value can be obtained as</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>ν</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-rel>=</mo><mfrac><mrow><mi>μ</mi></mrow><mrow><msup><mrow><mo class=MathClass-open>(</mo><mn>2</mn><mo class=MathClass-bin>−</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>μ</mi></mrow></msup><mo class=MathClass-close>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac><mo class=MathClass-rel>=</mo><mn>1</mn></math> <span class=cmti-10>.</span> <span class=cmti-10>Here again, the exact value of the Lagrange multiplier is obtained for each</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> <span class=cmti-10>because</span><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>g</mi></math> <span class=cmti-10>is a linear constraint.</span></div><p>The use of barrier functions for solving constrained NLP problems also faces several computational difficulties. First, the search must start with a point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></math> such that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , and finding such a point may not be an easy task for some problems. Also, because of the structure of the barrier function <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>b</mi></math> , and for small values of the parameter <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> , most search techniques may face serious ill-conditioning and difficulties with round-off errors while solving the problem to minimize <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> over <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></math> , especially as the boundary of the region <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-close>}</mo></math> is approached. Accordingly, interior-point algorithms employ a sequence of decreasing penalty parameters <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>}</mo><mo class=MathClass-rel>→</mo><mn>0</mn></math> as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>→</mo><mi>∞</mi></math> ; with each new value <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup></math> , an optimal solution to the barrier problem is sought by starting from the previous optimal solution. As in the exterior penalty function approach, it is highly recommended to use suitable second-order Newton or quasi-Newton methods for solving the successive barrier problems.<p>We describe below a scheme using barrier functions for optimizing a NLP problem. <a id=x1-33004r4></a><div class=mdframed id=mdframed-87><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.4</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>𝜖</mi><mo class=MathClass-rel>></mo><mn>0</mn></math> be a termination scalar, and choose an initial point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow></math> , with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mn>0</mn></math> . Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mn>0</mn></mrow></msup><mo class=MathClass-rel>></mo><mn>0</mn></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>β</mi><mo class=MathClass-rel>∈</mo><mo class=MathClass-open>(</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mn>1</mn><mo class=MathClass-close>)</mo></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize>Starting with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , get a solution to the problem:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>∈</mo><mi class=qopname>arg</mi><mo>⁡</mo><mi class=qopname>min</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>{</mo><mrow><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><mi>X</mi></mrow><mo fence=true form=postfix>}</mo></mrow></math></table><li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>b</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mi>𝜖</mi></math> , stop; otherwise, let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup><mo class=MathClass-rel>=</mo><mi>β</mi><msup><mrow><mi>μ</mi></mrow><mrow><mi>k</mi></mrow></msup></math> , replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><p>Note that although the constraint <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>&lt;</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> may be ignored, it is considered in the problem formulation as most line search methods use discrete steps, and a step could lead to a point outside the feasible region (where the value of the barrier function is a large negative number), when close to the boundary. Therefore, the problem can effectively be treated as an unconstrained optimization problem only if an explicit check for feasibility is made.<p>In recent years, there has been much excitement because some variants of the interior-point algorithm can be shown to be polynomial in time for many classes of <span class=cmti-10>convex</span> programs. Moreover, interior-point codes are now proving to be highly competitive with codes based on other algorithms, such as SQP algorithms presented subsequently. A number of free and commercial interior-point solvers are given in Tab. 1.1. below.<h4 class=subsectionHead><span class=titlemark>2.9.10</span> <a id=x1-340002.9.10></a>Sequential Quadratic Programming</h4><p>Sequential quadratic programming (SQP) methods, also known as successive, or recursive, quadratic programming, employ Newton’s method (or quasi-Newton methods) to directly solve the KKT conditions for the original problem. As a result, the accompanying subproblem turns out to be the minimization of a quadratic approximation to the Lagrangian function subject to a linear approximation to the constraints. Hence, this type of process is also known as a projected Lagrangian, or the Newton-Lagrange, approach. By its nature, this method produces both primal and dual (Lagrange multiplier) solutions.<p>To present the concept of SQP, consider first the equality constrained nonlinear program:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><munder class=msub><mrow><mi class=qopname>min</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></munder></mtd><mtd columnalign=left class=array><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> , and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-punc>:</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup><mo class=MathClass-rel>→</mo><mi>ℝ</mi></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-punc>:</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup><mo class=MathClass-rel>→</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></msup></math> are twice continuously differentiable. We shall also assume throughout that the equality constraints are linearly independent at a solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> . (The extension for including inequality constraints is considered subsequently.)<p>By Theorem <a href=#x1-20002r13>2.13</a>, the first-order necessary conditions of optimality for an equality constrained NLP require a primal solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></mrow></msup></math> and a Lagrange multiplier vector <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-rel>∈</mo><msup><mrow><mi>ℝ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></msup></math> such that:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-rel>=</mo><msub><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></msub><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right></mtd><mtd columnalign=left><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-rel>=</mo><msub><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle></mrow></msub><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> . Now, consider a Newton-like method to solve the latter system of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub><mo class=MathClass-bin>+</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></math> nonlinear equations. Given an iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> , a new iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></math> is obtained by solving the first-order approximation:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=bold><mn>0</mn></mstyle><mo class=MathClass-rel>=</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold-italic><msub><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow></msub></mstyle></mtd></mtr></mtable></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold-italic><msub><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow></msub></mstyle><mrow><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle></mrow><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>)</mo></mtd></mtr><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>+</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mtd></mtr></mtable></mrow><mo fence=true form=postfix>)</mo></mrow><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mtd><mtr><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></mtd><mtd columnalign=center class=array><mn>0</mn></mtd></mtr><mo fence=true form=postfix>)</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mtd></mtr></mtable></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mtd></mtr><mo fence=true form=postfix>)</mo></math></table><p>Substituting <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></msub><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , the first row of the system of equations is:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mrow><mo fence=true form=prefix>[</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>]</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mrow><mo fence=true form=prefix>[</mo><mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>]</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math></table><p>The Lagrange multiplier <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> can be simplified and thus:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mrow><mo fence=true form=prefix>[</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>]</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math></table><p>The second row of the system of equations is independent of the Lagrange multipliers, it is:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-close>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mrow><mo fence=true form=prefix>[</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>]</mo><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math></table><p>Therefore the system can be simplified as:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mtd></mtr></mtable></mrow><mo fence=true form=postfix>)</mo></mrow><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mtd><mtr><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></mtd><mtd columnalign=center class=array><mn>0</mn></mtd></mtr><mo fence=true form=postfix>)</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mtd></mtr></mtable></mrow><mrow><mi>k</mi></mrow><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mtd></mtr></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo fence=true form=postfix>)</mo><mo class=MathClass-rel>=</mo><mo class=MathClass-bin>−</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mtd></mtr></mtable></mrow><mtr><mtd columnalign=center class=array><mstyle mathvariant=bold><mi>h</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo></mtd></mtr></mrow><mo fence=true form=postfix>)</mo></math></table><p>Where we have defined the Newton step on <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> as <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>−</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> . The simplified system can be solved for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> if a solution exists. Setting <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , and incrementing <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi></math> by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math> , we can then repeat the process until <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> happens to solve the linear system. When this occurs, if at all, we shall have found a stationary point to the equality constrained NLP.<p>Interestingly enough, a <span class=cmti-10>quadratic programming</span> (QP) minimization subproblem can be employed in lieu of the foregoing linear system to find any optimal solution for the linearized NLP problem. Given <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> we define the subproblem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> as:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false><mtr><mtd columnalign=left class=array><munder class=msub><mrow><mi class=qopname>min</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></munder><mi>f</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo fence=true form=postfix>)</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mtd></mtr><mtr><mtd columnalign=left class=array><mstyle class=text><mtext> s.t. </mtext></mstyle><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>First, note that an optimum <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> , if it exists, together with the set of Lagrange multipliers <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> associated with the linearized constraints satisfies the linearized KKT conditions. Second, the objective function of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> represents not just a quadratic approximation for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> but also incorporates an additional term <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>{</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><msubsup><mrow><mi class=MathClass-op>∑</mi><mo>⁡</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></msubsup><msubsup><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msubsup><msup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mn>2</mn></mrow></msup><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mstyle mathsize=1.61em><mrow><mo fence=true form=prefix>}</mo><mrow></mrow><mo fence=true form=postfix></mo></mrow></mstyle><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> to represent the curvature of the constraints. <a id=x1-34001r5></a><div class=mdframed id=mdframed-88><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.5:</span> <span class=cmbx-10>SQP</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Choose and initial primal/dual point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-close>)</mo></math> , let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize>Solve the quadratic subproblem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> to obtain a solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> long with a set of Lagrange multipliers <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> .<li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , then <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></math> satisfies the stationarity conditions of the original NLP problem; stop. Otherwise, let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><p>In the case <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> is a regular stationary solution for the NLP problem which, together with a set of Lagrange multipliers <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> , satisfies the second-order sufficiency conditions of Theorem <a href=#x1-20019r16>2.16</a>, then the matrix<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mstyle mathvariant=normal><mi>W</mi></mstyle><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mrow><mo fence=true form=prefix>(</mo><mrow><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mtd></mtr></mtable></mrow><mo fence=true form=postfix>)</mo></mrow><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mrow><mo fence=true form=postfix>)</mo></mtd><mtr><mtd columnalign=center class=array><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></mtd><mtd columnalign=center class=array><mn>0</mn></mtd></mtr><mo fence=true form=postfix>)</mo></math></table><p>can be shown to be nonsingular. Hence, the above rudimentary SQP algorithm exhibits a quadratic rate of convergence by Theorem <a href=#x1-26002r21>2.21</a>.<p>We now consider the inclusion of inequality constraints <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mn>0</mn><mo class=MathClass-punc>,</mo><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-punc>,</mo><mspace class=thinspace width=0.3em></mspace><mi class=MathClass-op>…</mi><mo>⁡</mo><mspace class=thinspace width=0.3em></mspace><mo class=MathClass-punc>,</mo><mspace class=thinspace width=0.3em></mspace><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></math> in the NLP problem, that is:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines=none><mtr><mtd columnalign=center class=array><munder class=msub><mrow><mi class=qopname>min</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></munder></mtd><mtd columnalign=left class=array><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr><mtr><mtd columnalign=center class=array></mtd><mtd columnalign=left class=array><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>where the functions <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub></math> are twice continuously differentiable.<p>Given an iterate <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> , where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>≥</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> are the Lagrange multiplier estimates for the equality and inequality constraints, respectively, consider the following QP subproblem as a direct extension of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> :<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=array align=axis equalcolumns=false equalrows=false columnlines="none none"><mtr><mtd columnalign=center class=array><munder class=msub><mrow><mi class=qopname>min</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></munder></mtd><mtd columnalign=right class=array><mi>f</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><msup><mrow><mi>k</mi></mrow><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow></msup></mrow><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo fence=true form=postfix>)</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></mtd><mtd columnalign=left class=array></mtd></mtr><mtr><mtd columnalign=center class=array><mstyle class=text><mtext> s.t. </mtext></mstyle></mtd><mtd columnalign=right class=array><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>≤</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr><mtr><mtd columnalign=center class=array></mtd><mtd columnalign=right class=array><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>g</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>h</mi></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> . Note that the KKT conditions for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> require that, in addition to primal feasibility, Lagrange multipliers <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> be found such that:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>+</mo><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo fence=true form=postfix>)</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>h</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow><mo fence=true form=postfix>)</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=left><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right><msup><mrow><mrow><mo fence=true form=prefix>[</mo><mrow><mstyle mathvariant=bold><mi>g</mi></mstyle><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>+</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mstyle mathvariant=bold><mi>g</mi></mstyle><msup><mrow><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow></mrow></mrow></msup><mo fence=true form=postfix>)</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo fence=true form=postfix>]</mo><mrow><mi class=MathClass-op>⊤</mi><mo>⁡</mo></mrow><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></mtd><mtd columnalign=left><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></mtd></mtr></mtable></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-rel>≥</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> unrestricted in sign. Clearly, if <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , then <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> together with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></math> yields a KKT solution to the NLP original problem. Otherwise, we set <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> as before, increment <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi></math> by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>1</mn></math> , and repeat the process. Regarding convergence rate, it can be shown that if <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> is a regular KKT solution which, together with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> satisfies the second-order sufficient conditions of Theorem <a href=#x1-23002r18>2.18</a>, and if <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-close>)</mo></math> is initialized sufficiently close to <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> , then the foregoing iterative procedure shall exhibit a quadratic convergence rate.<p>The SQP method, as presented thus far, obviously shares the disadvantages of Newton’s method: (i) it requires second-order derivatives <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi></math> to be calculated, which in addition might not be positive definite, and (ii) it lacks the global convergence property.<ul class=itemize1><li class=itemize>Regarding second-order derivatives, a quasi-Newton positive definite approximation can be used for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi></math> . For example, given a positive definite approximation <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup></math> for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi></math> , the quadratic problem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> can be solved with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi></math> replaced by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup></math> . For example, an approximation of the inverse Hessian matrix can be obtained via a Broyden-like procedure, with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>γ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> given by<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msup><mrow><mi>γ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo fence=true form=postfix>)</mo><mo class=MathClass-bin>−</mo><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi mathvariant=bold-script>ℒ</mi><mrow><mo fence=true form=prefix>(</mo><mrow><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle></mrow><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo fence=true form=postfix>)</mo></math></table><p>It can be shown that this modification to the rudimentary SQP algorithm, similar to the quasi-Newton modification of Newton’s algorithm, looses the quadratic convergence rate property. Instead, it can be shown that the convergence is superlinear when initialized sufficiently close to a solution <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> that satisfies both regularity and second-order sufficiency conditions. However, this superlinear convergence rate is strongly based on the use of unit step sizes (see point (ii) below).<li class=itemize>In order to remedy the global convergence deficiency, a globalization strategy can be used, e.g., a line search procedure. Unlike unconstrained optimization problems, however, the choice of a suitable line search or <span class=cmti-10>merit</span> function providing a measure of progress is not obvious in the presence of constraints. Two such popular choices of a line search function are:<ul class=itemize2><li class=itemize>The <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> <span class=cmti-10>Merit Function</span>:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>;</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>μ</mi><mrow><mo fence=true form=prefix>[</mo><mrow><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></munderover><mrow><mo fence=true form=prefix>|</mo><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>|</mo></mrow><mo class=MathClass-bin>+</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><mi class=qopname>max</mi><mo>⁡</mo><mrow><mo fence=true form=prefix>{</mo><mrow><mn>0</mn><mo class=MathClass-punc>,</mo><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>}</mo></mrow></mrow><mo fence=true form=postfix>]</mo></mrow></math></table><p>which satisfies the important property that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> is a local minimizer of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> , provided <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow><mo class=MathClass-close>)</mo></math> satisfies the second-order sufficient conditions (see Theorem <a href=#x1-23002r18>2.18</a>) and the penalty parameter <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> is so chosen that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><mo class=MathClass-rel>|</mo><msubsup><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msubsup><mo class=MathClass-rel>|</mo></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>,</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-punc>,</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi><mo class=MathClass-rel>></mo><msubsup><mrow><mi>ν</mi></mrow><mrow><mi>i</mi></mrow><mrow><mo class=MathClass-bin>⋆</mo></mrow></msubsup></math> , <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>,</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-punc>,</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></math> . Yet, the <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>1</mn></mrow></msub></math> merit function is not differentiable at those <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi></mstyle></math> with either <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>0</mn></math> or <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mn>0</mn></math> , and it can be unbounded below even though <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> is a local minimizer.<li class=itemize>The <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>2</mn></mrow></msub></math> <span class=cmti-10>Augmented Lagrangian (ALAG) Merit Function</span>:<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-punc>;</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></munderover><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mfrac><mrow><mi>μ</mi></mrow><mrow><mn>2</mn></mrow></mfrac><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>h</mi></mrow></msub></mrow></munderover><msup><mrow><mrow><mo fence=true form=prefix>[</mo><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mo fence=true form=postfix>]</mo></mrow></mrow><mrow><mn>2</mn></mrow></msup><mo class=MathClass-bin>+</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></mfrac><munderover accent=false accentunder=false><mrow><mo>∑</mo></mrow><mrow><mi>i</mi><mo class=MathClass-rel>=</mo><mn>1</mn></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></munderover><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-punc>;</mo><mi>μ</mi><mo class=MathClass-close>)</mo></math></table><p>with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-punc>;</mo><mi>μ</mi><mo class=MathClass-close>)</mo><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mfrac><mrow><mn>1</mn></mrow><mrow><mi>μ</mi></mrow></mfrac><mrow><mo fence=true form=prefix>(</mo><mrow><mi class=qopname>max</mi><mo>⁡</mo><msup><mrow><mo class=MathClass-open>{</mo><mn>0</mn><mo class=MathClass-punc>,</mo><msub><mrow><mi>ν</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-bin>+</mo><mi>μ</mi><msub><mrow><mi>g</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-close>}</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class=MathClass-bin>−</mo><msubsup><mrow><mi>ν</mi></mrow><mrow><mi>i</mi></mrow><mrow><mn>2</mn></mrow></msubsup></mrow><mo fence=true form=postfix>)</mo></mrow></math> , has similar properties to the <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>l</mi></mrow><mrow><mn>1</mn></mrow></msub></math> merit function, provided <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> is chosen large enough, and is continuously differentiable (although its Hessian matrix is discontinuous). Yet, for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> to be a (local) minimizer of <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-punc>;</mo><mi>μ</mi><mo class=MathClass-close>)</mo></math> , it is necessary that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>λ</mi></mstyle><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>ν</mi></mstyle><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mo class=MathClass-bin>⋆</mo></mrow></math> .</ul></ul><p>An SQP algorithm including the modifications discussed in (i) and (ii) is as follows: <a id=x1-34002r6></a><div class=mdframed id=mdframed-89><p><span class=cmbx-10>Algorithm</span><span class=cmbx-10> 2.6:</span> <span class=cmbx-10>Improved</span> <span class=cmbx-10>SQP</span><p><strong><span class=cmbx-10>Initialization Step:</span></strong><p>Choose and initial primal/dual point <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-close>)</mo></math> , with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mn>0</mn></mrow><mo class=MathClass-rel>≥</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , and a positive definite matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mn>0</mn></mrow></msup></math> . Let <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>0</mn></math> , and go to the main step.<p><strong><span class=cmbx-10>Main Step:</span></strong><ul class=itemize1><li class=itemize>Solve the quadratic subproblem <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle class=text><mtext>QP</mtext></mstyle><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> , with<br class=newline><math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msubsup><mrow><mi class=MathClass-op>∇</mi><mo>⁡</mo></mrow><mrow><mstyle mathvariant=bold><mi>x</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> replaced by <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup></math> , to obtain a direction <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> along with a set of Lagrange multipliers <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></math> .<li class=itemize>If <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , then <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>λ</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>,</mo><mstyle mathvariant=bold-italic><msup><mrow><mi>ν</mi></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-close>)</mo></math> satisfies the KKT conditions of the original NLP problem; stop.<li class=itemize>Find <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><msup><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msup><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow></math> , where <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msup></math> improves <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>ℓ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-bin>+</mo><mi>α</mi><mstyle mathvariant=bold><mi>d</mi><msup><mrow></mrow></msup></mstyle><mrow><mi>k</mi></mrow><mo class=MathClass-close>)</mo></math> over <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>{</mo><mi>α</mi><mo class=MathClass-rel>∈</mo><mi>ℝ</mi><mo class=MathClass-punc>:</mo><mi>α</mi><mo class=MathClass-rel>></mo><mn>0</mn><mo class=MathClass-close>}</mo></math> [or any other suitable merit function]. Update <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi></mrow></msup></math> to a positive definite matrix <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msup><mrow><mi>B</mi></mrow><mrow><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></mrow></msup></math> [e.g., according to the quasi-Newton update]. Replace <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>←</mo><mi>k</mi><mo class=MathClass-bin>+</mo><mn>1</mn></math> , and go to step 1.</ul></div><p>What Can Go Wrong?<p>The material presented up to this point was intended to give the reader an understanding of how SQP methods should work. Things do not go so smoothly in practice though. We now discuss a number of common difficulties that can be encountered, and suggest remedial actions to correct the deficiencies. Because real applications may involve more than a single difficulty, the user must be prepared to correct all problems before obtaining satisfactory performance from an optimization software.<ul class=itemize1><li class=itemize><strong><span class=cmbx-10>Infeasible Constraints</span></strong><p>One of the most common difficulties occurs when the NLP problem has infeasible constraints, i.e., the constraints taken all together have <span class=cmti-10>no</span> solution. Applying general-purpose SQP software to such problems typically produces one or more of the following symptoms:<ul class=itemize2><li class=itemize>one of the QP subproblem happen to be infeasible, which occurs when the linearized constraints have no solution;<li class=itemize>many NLP iterations produce very little progress;<li class=itemize>the penalty parameters <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> of the merit functions growsvery large;<li class=itemize>the Lagrange multipliers become very large.</ul><p>Although robust SQP software attempt to diagnose this situation, ultimately the only remedy is to reformulate the NLP.<li class=itemize><strong><span class=cmbx-10>Rank-Deficient Constraints</span></strong><p>In contrast to the previous situation, it is possible that the constraints be consistent, but the Jacobian matrix of the active constraints, at the solution point, be either ill-conditioned or rank deficient. This situation was illustrated in Examples 1.43 and 1.55. The application of general-purpose SQP software is likely to produce the following symptoms:<ul class=itemize2><li class=itemize>many NLP iterations produce very little progress;<li class=itemize>the penalty parameters <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>μ</mi></math> of the merit functions grows very large;<li class=itemize>the Lagrange multipliers become very large;<li class=itemize>the rank deficiency in the Jacobian of the active constraints is detected.</ul><p>Note that many symptoms of rank-deficient constraints are the same as those of inconsistent constraints. It is therefore quite common to confuse this deficiency with inconsistent constraints. Again, the remedy is to reformulate the problem.<li class=itemize><strong><span class=cmbx-10>Redundant Constraints</span></strong><p>A third type of difficulty occurs when the NLP problem contains redundant constraints. Two types of redundancy may be distinguished. In the first type, some of the constraints are unnecessary to the problem formulation, which typically results in the following symptoms:<ul class=itemize2><li class=itemize>the Lagrange multipliers are close to zero;<li class=itemize>the solver has difficulty in detecting the active set.</ul><p>In the second type, the redundant constraints give rise to rank deficiency, and the problem then exhibits symptoms similar to the rank-deficient case discussed previously. Obviously, the remedy is to reformulate the problem by eliminating the redundant constraints.<li class=itemize><strong><span class=cmbx-10>Discontinuities</span></strong><p>Perhaps the biggest obstacle encountered in the practical application of SQP methods (as well as many other NLP methods including SUM techniques) is the presence of discontinuous behavior. All of the numerical methods described herein assume continuous and differentiable objective function and constraints. Yet, there are many common examples of discontinuous functions in practice, including: IF tests in codes; absolute value, <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=qopname>min</mi><mo>⁡</mo></math> , and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=qopname>max</mi><mo>⁡</mo></math> functions; linear interpolation of data; internal iterations such as root finding; etc.<p>Regarding SQP methods, the standard QP subproblems are no longer appropriate when discontinuities are present. In fact, the KKT necessary conditions simply do not apply! The most common symptoms of discontinuous functions are:<ul class=itemize2><li class=itemize>the iterates converge slowly or, even, diverge;<li class=itemize>the line search takes very small steps <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mi>α</mi><mo class=MathClass-rel>≈</mo><mn>0</mn><mo class=MathClass-close>)</mo></math> ;<li class=itemize>the Hessian matrix becomes badly ill-conditioned.</ul><p>The remedy consists in reformulating discontinuous problems into smooth problems: for absolute value, min, and max functions, tricks can be used that introduce slack variables and additional constraints; linear data interpolation can be replaced by higher order interpolation schemes that are continuous through second derivatives; internal iterations can also be handled via additional NLP constraints; etc.<li class=itemize><strong><span class=cmbx-10>Inaccurate Gradient Estimation</span></strong><p>Any SQP code requires that the user supply the objective function and constraint values, as well as their gradient (and possibly their Hessian too). In general, the user is proposed the option to calculate the gradients via finite differences, e.g.,<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>≈</mo><mfrac><mrow><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-bin>+</mo><mi>δ</mi><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>−</mo><mi>f</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></mrow><mrow><mi>δ</mi><mstyle mathvariant=bold><mi>x</mi></mstyle></mrow></mfrac></math></table><p>However, this may cause the problem to stop prematurely. First of all, the choice of the perturbation vector <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mstyle mathvariant=bold-italic><mi>δ</mi></mstyle><mstyle mathvariant=bold><mi>x</mi></mstyle></math> is highly non trivial. If too large a value clearly provides inaccurate estimates, too small a value may also result in very bad estimates due to finite arithmetic precision computations. Therefore, one must try to find a trade-off between these two extreme situations. The difficulty stems from the fact that a trade-off may not necessarily exist if the requested accuracy for the gradient is too high. In other word, the error made in the finite-difference approximation of a gradient <span class=cmti-10>cannot</span> be made as small as desired. Further, the maximum accuracy that can be achieved with finite difference is both problem dependent (e.g., badly-scaled functions are more problematic than well-scaled functions) and machine dependent (e.g., double precision computations provides more accurate estimates than single precision computations). Typical symptoms of inaccurate gradient estimates in an SQP code are:<ul class=itemize2><li class=itemize>the iterates converge slowly, and the solver may stop prematurely at a suboptimal point (jamming);<li class=itemize>the line search takes very small steps <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-open>(</mo><mi>α</mi><mo class=MathClass-rel>≈</mo><mn>0</mn><mo class=MathClass-close>)</mo></math> .</ul><p>The situation can be understood as follows. Assume that the gradient estimate is contaminated with noise. Then, instead of computing the true value <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo></math> , we get <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-bin>+</mo><mi>𝜖</mi></math> . But since the iteration seeks a point such that <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi class=MathClass-op>∇</mi><mo>⁡</mo><mi mathvariant=bold-script>ℒ</mi><mo class=MathClass-open>(</mo><mstyle mathvariant=bold><mi>x</mi></mstyle><mo class=MathClass-close>)</mo><mo class=MathClass-rel>=</mo><mstyle mathvariant=bold><mn>0</mn></mstyle></math> , we can expect either a degraded rate of convergence or, worse, no convergence at all, because ultimately the gradient will be dominated by noise.<p>To avoid these problems, the user should always consider providing the gradients explicitely to the SQP solver, instead of relying on finite-difference estimates. For large-scale problems, this is obviously a time-consuming and error-prone task. In response to this, efficient <span class=cmti-10>algorithmic differentiation</span> tools (also called automatic differentiation) have been developed within the last fifteen years. The idea behind it is that, given a piece of program calculating a number of function values (e.g., in fortran77 or C language), an auxiliary program is generated that calculates the derivatives of these functions.<li class=itemize><strong><span class=cmbx-10>Scaling</span></strong><p>Scaling affects everything! Poor scaling can make a good algorithm behave badly. Scaling changes the convergence rate, termination tests, and numerical conditioning.<p>The most common way of scaling a problem is by introducing scaled variables of the form<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><msub><mrow><mover accent=true><mrow><mi>x</mi></mrow><mo accent=true>~</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-bin>+</mo><msub><mrow><mi>r</mi></mrow><mrow><mi>k</mi></mrow></msub></math></table><p>for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>,</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>,</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>x</mi></mrow></msub></math> with <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>u</mi></mrow><mrow><mi>k</mi></mrow></msub></math> and <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><msub><mrow><mi>r</mi></mrow><mrow><mi>k</mi></mrow></msub></math> being scale weights and shifts, respectively. Likewise, the objective function and constraints are commonly scaled using<table class=equation-star><tr><td><math display=block xmlns=http://www.w3.org/1998/Math/MathML class=equation><mtable class=aligned><mtr><mtd columnalign=right><mover accent=true><mrow><mi>f</mi></mrow><mo accent=true>~</mo></mover></mtd><mtd columnalign=left><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><msub><mrow><mi>ω</mi></mrow><mrow><mn>0</mn></mrow></msub><mi>f</mi></mtd><mtd columnalign=right></mtd></mtr><mtr><mtd columnalign=right><msub><mrow><mover accent=true><mrow><mi>g</mi></mrow><mo accent=true>~</mo></mover></mrow><mrow><mi>k</mi></mrow></msub></mtd><mtd columnalign=left><mo class=MathClass-punc>:</mo><mo class=MathClass-rel>=</mo><msub><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>g</mi></mrow><mrow><mi>k</mi></mrow></msub></mtd></mtr></mtable></math></table><p>for <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mi>k</mi><mo class=MathClass-rel>=</mo><mn>1</mn><mo class=MathClass-punc>,</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>.</mo><mo class=MathClass-punc>,</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></math> . The idea is to let the optimization algorithm work with the well-scaled quantities in order to improve performance. However, what well-scaled quantities mean is hard to define, although conventional wisdom suggests the following hints:<ul class=itemize2><li class=itemize>normalize the independent variables to have the same range, e.g., <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mn>0</mn><mo class=MathClass-rel>≤</mo><msub><mrow><mover accent=true><mrow><mi>x</mi></mrow><mo accent=true>~</mo></mover></mrow><mrow><mi>k</mi></mrow></msub><mo class=MathClass-rel>≤</mo><mn>1</mn></math> ;<li class=itemize>normalize the dependent functions to have the same magnitude, e.g., <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mover accent=true><mrow><mi>f</mi></mrow><mo accent=true>~</mo></mover><mo class=MathClass-rel>≈</mo><msub><mrow><mover accent=true><mrow><mi>g</mi></mrow><mo accent=true>~</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-rel>≈</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-rel>≈</mo><msub><mrow><mover accent=true><mrow><mi>g</mi></mrow><mo accent=true>~</mo></mover></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></msub><mo class=MathClass-rel>≈</mo><mn>1</mn></math> ;<li class=itemize>normalize the rows and columns of the Jacobian to be of the same magnitude;<li class=itemize>scale the dependent functions so that the Lagrange multipliers are close to one, e.g., <math display=inline xmlns=http://www.w3.org/1998/Math/MathML><mo class=MathClass-rel>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class=MathClass-rel>|</mo><mo class=MathClass-rel>≈</mo><mi class=MathClass-op>…</mi><mo>⁡</mo><mo class=MathClass-rel>≈</mo><mo class=MathClass-rel>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>g</mi></mrow></msub></mrow></msub><mo class=MathClass-rel>|</mo><mo class=MathClass-rel>≈</mo><mn>1</mn></math> ; etc.</ul></ul></div></div><footer class=fixed-bottom-footer><div class="w3-container w3-theme-l1"><p>© Copyright 2020 <a href=https://polimechatronics.github.io/ target=_blank>Mechatronic Systems and Laboratory</a> course at <a href=https://polimi.it/ target=_blank>Politecnico di Milano</a></div></footer></div><script src=https://hypothes.is/embed.js async></script><script type=text/x-mathjax-config>MathJax.Hub.Config({ extensions: ["tex2jax.js"], jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true }, "HTML-CSS": { availableFonts: ["TeX"] } });</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script>var mySidebar=document.getElementById("mySidebar"),overlayBg=document.getElementById("myOverlay");function w3_open(){"block"===mySidebar.style.display?(mySidebar.style.display="none",overlayBg.style.display="none"):(mySidebar.style.display="block",overlayBg.style.display="block")}function w3_close(){mySidebar.style.display="none",overlayBg.style.display="none"}</script>